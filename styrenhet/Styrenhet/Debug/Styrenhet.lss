
Styrenhet.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000033e  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000002  00800060  0000033e  000003b2  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .comment      00000030  00000000  00000000  000003b4  2**0
                  CONTENTS, READONLY
  3 .debug_aranges 00000118  00000000  00000000  000003e4  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   000009c4  00000000  00000000  000004fc  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_abbrev 000003a3  00000000  00000000  00000ec0  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_line   000004ab  00000000  00000000  00001263  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_frame  00000214  00000000  00000000  00001710  2**2
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_str    0000033a  00000000  00000000  00001924  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_loc    00000812  00000000  00000000  00001c5e  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 00000100  00000000  00000000  00002470  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 37 00 	jmp	0x6e	; 0x6e <__ctors_end>
   4:	0c 94 4c 00 	jmp	0x98	; 0x98 <__bad_interrupt>
   8:	0c 94 4c 00 	jmp	0x98	; 0x98 <__bad_interrupt>
   c:	0c 94 4c 00 	jmp	0x98	; 0x98 <__bad_interrupt>
  10:	0c 94 4c 00 	jmp	0x98	; 0x98 <__bad_interrupt>
  14:	0c 94 4c 00 	jmp	0x98	; 0x98 <__bad_interrupt>
  18:	0c 94 4c 00 	jmp	0x98	; 0x98 <__bad_interrupt>
  1c:	0c 94 4c 00 	jmp	0x98	; 0x98 <__bad_interrupt>
  20:	0c 94 4c 00 	jmp	0x98	; 0x98 <__bad_interrupt>
  24:	0c 94 4c 00 	jmp	0x98	; 0x98 <__bad_interrupt>
  28:	0c 94 4c 00 	jmp	0x98	; 0x98 <__bad_interrupt>
  2c:	0c 94 4c 00 	jmp	0x98	; 0x98 <__bad_interrupt>
  30:	0c 94 4c 00 	jmp	0x98	; 0x98 <__bad_interrupt>
  34:	0c 94 4c 00 	jmp	0x98	; 0x98 <__bad_interrupt>
  38:	0c 94 4c 00 	jmp	0x98	; 0x98 <__bad_interrupt>
  3c:	0c 94 4c 00 	jmp	0x98	; 0x98 <__bad_interrupt>
  40:	0c 94 4c 00 	jmp	0x98	; 0x98 <__bad_interrupt>
  44:	0c 94 4c 00 	jmp	0x98	; 0x98 <__bad_interrupt>
  48:	0c 94 4c 00 	jmp	0x98	; 0x98 <__bad_interrupt>
  4c:	0c 94 4c 00 	jmp	0x98	; 0x98 <__bad_interrupt>
  50:	0c 94 4c 00 	jmp	0x98	; 0x98 <__bad_interrupt>
  54:	b4 00       	.word	0x00b4	; ????
  56:	04 01       	movw	r0, r8
  58:	04 01       	movw	r0, r8
  5a:	b7 00       	.word	0x00b7	; ????
  5c:	bc 00       	.word	0x00bc	; ????
  5e:	04 01       	movw	r0, r8
  60:	d3 00       	.word	0x00d3	; ????
  62:	d9 00       	.word	0x00d9	; ????
  64:	df 00       	.word	0x00df	; ????
  66:	e5 00       	.word	0x00e5	; ????
  68:	eb 00       	.word	0x00eb	; ????
  6a:	ee 00       	.word	0x00ee	; ????
  6c:	f1 00       	.word	0x00f1	; ????

0000006e <__ctors_end>:
  6e:	11 24       	eor	r1, r1
  70:	1f be       	out	0x3f, r1	; 63
  72:	cf e5       	ldi	r28, 0x5F	; 95
  74:	d4 e0       	ldi	r29, 0x04	; 4
  76:	de bf       	out	0x3e, r29	; 62
  78:	cd bf       	out	0x3d, r28	; 61

0000007a <__do_copy_data>:
  7a:	10 e0       	ldi	r17, 0x00	; 0
  7c:	a0 e6       	ldi	r26, 0x60	; 96
  7e:	b0 e0       	ldi	r27, 0x00	; 0
  80:	ee e3       	ldi	r30, 0x3E	; 62
  82:	f3 e0       	ldi	r31, 0x03	; 3
  84:	02 c0       	rjmp	.+4      	; 0x8a <__do_copy_data+0x10>
  86:	05 90       	lpm	r0, Z+
  88:	0d 92       	st	X+, r0
  8a:	a2 36       	cpi	r26, 0x62	; 98
  8c:	b1 07       	cpc	r27, r17
  8e:	d9 f7       	brne	.-10     	; 0x86 <__do_copy_data+0xc>
  90:	0e 94 14 01 	call	0x228	; 0x228 <main>
  94:	0c 94 9d 01 	jmp	0x33a	; 0x33a <_exit>

00000098 <__bad_interrupt>:
  98:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000009c <init_pwm>:
	//	Controls TEH CLAW
	//	WGM decides the pwm mode			| WGM00 & WGM01 => fast pwm
	//	CS sets the prescaler				| CS02 & CS00 => CLK/1024
	//	COM sets the compare output mode	| COM01 => Clear OC0 on match, set on BOTTOM
	/************************************************************************/
	CLAW_TIMER |= (1 << WGM00) | (1 << WGM01) | (1 << CS02) | (1 << CS00);
  9c:	83 b7       	in	r24, 0x33	; 51
  9e:	8d 64       	ori	r24, 0x4D	; 77
  a0:	83 bf       	out	0x33, r24	; 51
	DDRB |= (1 << CLAW_PIN); // sets OC0 as output
  a2:	bb 9a       	sbi	0x17, 3	; 23
	//	Controls the wheel servos
	//	WGM decides the pwm	mode			| WGM10 & WGM12 => fast pwm, 8-bit
	//	CS sets the prescaler				| CS12 & CS10 => CLK/1024
	//	COM sets the compare output mode	| COM1A1 & COM1B1 => Clear OC1A:B on match, set on BOTTOM
	/************************************************************************/
	WHEEL_TIMER_A |= (1 << COM1A1) | (1 << COM1B1) | (1 << WGM10);
  a4:	8f b5       	in	r24, 0x2f	; 47
  a6:	81 6a       	ori	r24, 0xA1	; 161
  a8:	8f bd       	out	0x2f, r24	; 47
	WHEEL_TIMER_B |= (1 << WGM12) | (1 << CS12) | (1 << CS10);
  aa:	8e b5       	in	r24, 0x2e	; 46
  ac:	8d 60       	ori	r24, 0x0D	; 13
  ae:	8e bd       	out	0x2e, r24	; 46
	DDRD |= (1 << RIGHT_WHEEL_PIN) | (1 << LEFT_WHEEL_PIN); // sets 0C1A:B as outputs (OC1A = Left, OC1B = Right)	
  b0:	81 b3       	in	r24, 0x11	; 17
  b2:	80 63       	ori	r24, 0x30	; 48
  b4:	81 bb       	out	0x11, r24	; 17
  b6:	08 95       	ret

000000b8 <setSpeed>:
}

// Sets the duty cycle of both motors to speed
void setSpeed(uint8_t speed) {
	LEFT_WHEEL_VALUE = speed;
  b8:	8a bd       	out	0x2a, r24	; 42
	RIGHT_WHEEL_VALUE = speed;	
  ba:	88 bd       	out	0x28, r24	; 40
  bc:	08 95       	ret

000000be <setSpeeds>:
}

// Sets the duty cycle of the left motors to speed_left and the right motors to speed_right
void setSpeeds(uint8_t speed_left, uint8_t speed_right) {	
	LEFT_WHEEL_VALUE = speed_left;	
  be:	8a bd       	out	0x2a, r24	; 42
	RIGHT_WHEEL_VALUE = speed_right;
  c0:	68 bd       	out	0x28, r22	; 40
  c2:	08 95       	ret

000000c4 <clawGrip>:
	RIGHT_WHEEL_VALUE = speed;
}

// Makes the claw grip
void clawGrip() {
	CLAW_VALUE = 5;	
  c4:	85 e0       	ldi	r24, 0x05	; 5
  c6:	8c bf       	out	0x3c, r24	; 60
  c8:	08 95       	ret

000000ca <clawRelease>:
}

// Makes the claw release its grip
void clawRelease() {
	CLAW_VALUE = 11;
  ca:	8b e0       	ldi	r24, 0x0B	; 11
  cc:	8c bf       	out	0x3c, r24	; 60
  ce:	08 95       	ret

000000d0 <clawEnable>:
}

// Enables the claw for gripping
void clawEnable() {
	CLAW_TIMER |= (1<<COM01);
  d0:	83 b7       	in	r24, 0x33	; 51
  d2:	80 62       	ori	r24, 0x20	; 32
  d4:	83 bf       	out	0x33, r24	; 51
  d6:	08 95       	ret

000000d8 <clawDisable>:
}

// Disables the claw for when it's not in use since there is no need for it to constantly force itself open
// Saves battery life, motor wear and our ears
void clawDisable() {
	CLAW_TIMER &= ~(1<<COM01);
  d8:	83 b7       	in	r24, 0x33	; 51
  da:	8f 7d       	andi	r24, 0xDF	; 223
  dc:	83 bf       	out	0x33, r24	; 51
  de:	08 95       	ret

000000e0 <SPI_Init>:

#define WAIT_FOR_TRANSFER while(!(SPSR & (1<<SPIF)));

// Initiates the SPI
void SPI_Init(void) {
	DDR_SPI = (1<<SPI_MISO);		// Set MISO output
  e0:	80 e4       	ldi	r24, 0x40	; 64
  e2:	87 bb       	out	0x17, r24	; 23
	SPCR = (1<<SPE);				// Enable SPI
  e4:	8d b9       	out	0x0d, r24	; 13
	SPCR |= (1<<SPIE);				// Enable interrupts
  e6:	6f 9a       	sbi	0x0d, 7	; 13
	SPCR |= (1<<SPR0);				// Prescaler 16
  e8:	68 9a       	sbi	0x0d, 0	; 13
  ea:	08 95       	ret

000000ec <SPI_Receive>:
}

// Receive from SPI
char SPI_Receive(void) {
	WAIT_FOR_TRANSFER;				// Wait for reception to complete
  ec:	77 9b       	sbis	0x0e, 7	; 14
  ee:	fe cf       	rjmp	.-4      	; 0xec <SPI_Receive>
	char data = SPDR;
  f0:	8f b1       	in	r24, 0x0f	; 15
	SPDR = 0x00;
  f2:	1f b8       	out	0x0f, r1	; 15
	return data;					// Return Data Register
}
  f4:	08 95       	ret

000000f6 <receiveMessage>:
	WAIT_FOR_TRANSFER;				// Wait for transition to complete
	return;
}

// Receive a message from our main CPU
void receiveMessage() {
  f6:	af 92       	push	r10
  f8:	bf 92       	push	r11
  fa:	cf 92       	push	r12
  fc:	df 92       	push	r13
  fe:	ef 92       	push	r14
 100:	ff 92       	push	r15
 102:	0f 93       	push	r16
 104:	1f 93       	push	r17
 106:	cf 93       	push	r28
 108:	df 93       	push	r29
 10a:	cd b7       	in	r28, 0x3d	; 61
 10c:	de b7       	in	r29, 0x3e	; 62
				}
				break;
		}
	}

 10e:	0d b7       	in	r16, 0x3d	; 61
 110:	1e b7       	in	r17, 0x3e	; 62
	return;
}

// Receive a message from our main CPU
void receiveMessage() {
	char msg = SPI_Receive();
 112:	0e 94 76 00 	call	0xec	; 0xec <SPI_Receive>
 116:	f8 2e       	mov	r15, r24
	char size = SPI_Receive();
 118:	0e 94 76 00 	call	0xec	; 0xec <SPI_Receive>
	char header = msg >> 6;	
	msg = msg & 0x3F;
	char speed;	
	char left_dir, right_dir, left_speed, right_speed;
	char unknownMessage[size]; //couldn't be down in the default..
 11c:	2d b7       	in	r18, 0x3d	; 61
 11e:	3e b7       	in	r19, 0x3e	; 62
 120:	28 1b       	sub	r18, r24
 122:	31 09       	sbc	r19, r1
 124:	0f b6       	in	r0, 0x3f	; 63
 126:	f8 94       	cli
 128:	3e bf       	out	0x3e, r19	; 62
 12a:	0f be       	out	0x3f, r0	; 63
 12c:	2d bf       	out	0x3d, r18	; 61
 12e:	2f 5f       	subi	r18, 0xFF	; 255
 130:	3f 4f       	sbci	r19, 0xFF	; 255

// Receive a message from our main CPU
void receiveMessage() {
	char msg = SPI_Receive();
	char size = SPI_Receive();
	char header = msg >> 6;	
 132:	9f 2d       	mov	r25, r15
 134:	92 95       	swap	r25
 136:	96 95       	lsr	r25
 138:	96 95       	lsr	r25
 13a:	93 70       	andi	r25, 0x03	; 3
	msg = msg & 0x3F;
	char speed;	
	char left_dir, right_dir, left_speed, right_speed;
	char unknownMessage[size]; //couldn't be down in the default..
	
	if(header == 0x01) {							// Make sure that the message is meant for us
 13c:	91 30       	cpi	r25, 0x01	; 1
 13e:	09 f0       	breq	.+2      	; 0x142 <receiveMessage+0x4c>
 140:	63 c0       	rjmp	.+198    	; 0x208 <receiveMessage+0x112>
// Receive a message from our main CPU
void receiveMessage() {
	char msg = SPI_Receive();
	char size = SPI_Receive();
	char header = msg >> 6;	
	msg = msg & 0x3F;
 142:	4f 2d       	mov	r20, r15
 144:	4f 73       	andi	r20, 0x3F	; 63
	char speed;	
	char left_dir, right_dir, left_speed, right_speed;
	char unknownMessage[size]; //couldn't be down in the default..
	
	if(header == 0x01) {							// Make sure that the message is meant for us
		switch(msg) {								// Identify the message and act accordingly 
 146:	50 e0       	ldi	r21, 0x00	; 0
 148:	fa 01       	movw	r30, r20
 14a:	31 97       	sbiw	r30, 0x01	; 1
 14c:	ed 30       	cpi	r30, 0x0D	; 13
 14e:	f1 05       	cpc	r31, r1
 150:	20 f4       	brcc	.+8      	; 0x15a <receiveMessage+0x64>
 152:	e6 5d       	subi	r30, 0xD6	; 214
 154:	ff 4f       	sbci	r31, 0xFF	; 255
 156:	0c 94 97 01 	jmp	0x32e	; 0x32e <__tablejump2__>
				break;
			case 0x0D: //STOP
				wheelSpeeds(0, 0);
				break;
			default:	// Fetch the message anyway								
				for(int i = 0; i < size; i++) {
 15a:	a8 2e       	mov	r10, r24
 15c:	b1 2c       	mov	r11, r1
 15e:	1a 14       	cp	r1, r10
 160:	1b 04       	cpc	r1, r11
 162:	0c f4       	brge	.+2      	; 0x166 <receiveMessage+0x70>
 164:	43 c0       	rjmp	.+134    	; 0x1ec <receiveMessage+0xf6>
 166:	50 c0       	rjmp	.+160    	; 0x208 <receiveMessage+0x112>
	char unknownMessage[size]; //couldn't be down in the default..
	
	if(header == 0x01) {							// Make sure that the message is meant for us
		switch(msg) {								// Identify the message and act accordingly 
			case 0x01:	// Forward with pd				
				speed = SPI_Receive();
 168:	0e 94 76 00 	call	0xec	; 0xec <SPI_Receive>
				speed = speed << 1;
				//pdForward(speed);	TODO			
				break;
 16c:	4d c0       	rjmp	.+154    	; 0x208 <receiveMessage+0x112>
				break;
			case 0x03:	// Turn off pd				
				//setPd(off); TODO
				break;
			case 0x04:	// Switch forward/backward (used when reversing through the labyrinth)
				msg = SPI_Receive();
 16e:	0e 94 76 00 	call	0xec	; 0xec <SPI_Receive>
				setDirection(msg);
 172:	0e 94 1b 01 	call	0x236	; 0x236 <setDirection>
				break;
 176:	48 c0       	rjmp	.+144    	; 0x208 <receiveMessage+0x112>
			case 0x05:	// Set the speed/direction for the different motors
				left_speed = SPI_Receive();
 178:	0e 94 76 00 	call	0xec	; 0xec <SPI_Receive>
 17c:	f8 2e       	mov	r15, r24
				left_dir = left_speed >> 7;
				left_speed = left_speed << 1;
				leftWheelDirection(left_dir);				
 17e:	88 1f       	adc	r24, r24
 180:	88 27       	eor	r24, r24
 182:	88 1f       	adc	r24, r24
 184:	0e 94 5d 01 	call	0x2ba	; 0x2ba <leftWheelDirection>
				
				right_speed = SPI_Receive();				
 188:	0e 94 76 00 	call	0xec	; 0xec <SPI_Receive>
 18c:	e8 2e       	mov	r14, r24
				right_dir = right_speed >> 7;
				right_speed = right_speed << 1;
				rightWheelDirection(right_dir);
 18e:	88 1f       	adc	r24, r24
 190:	88 27       	eor	r24, r24
 192:	88 1f       	adc	r24, r24
 194:	0e 94 6e 01 	call	0x2dc	; 0x2dc <rightWheelDirection>
				left_speed = left_speed << 1;
				leftWheelDirection(left_dir);				
				
				right_speed = SPI_Receive();				
				right_dir = right_speed >> 7;
				right_speed = right_speed << 1;
 198:	6e 2d       	mov	r22, r14
 19a:	66 0f       	add	r22, r22
				rightWheelDirection(right_dir);
				wheelSpeeds(left_speed, right_speed);
 19c:	8f 2d       	mov	r24, r15
 19e:	88 0f       	add	r24, r24
 1a0:	0e 94 7f 01 	call	0x2fe	; 0x2fe <wheelSpeeds>
				break;
 1a4:	31 c0       	rjmp	.+98     	; 0x208 <receiveMessage+0x112>
			case 0x06:	// Set the p and d values
				// setPD(p, d); to be implemented
				break;
			case 0x07:	// Move forward with the specified speed
				speed = SPI_Receive() << 1;			
 1a6:	0e 94 76 00 	call	0xec	; 0xec <SPI_Receive>
				driveForward(speed);
 1aa:	88 0f       	add	r24, r24
 1ac:	0e 94 25 01 	call	0x24a	; 0x24a <driveForward>
				break;
 1b0:	2b c0       	rjmp	.+86     	; 0x208 <receiveMessage+0x112>
			case 0x08:	// Move backward with the specified speed
				speed = SPI_Receive() << 1;
 1b2:	0e 94 76 00 	call	0xec	; 0xec <SPI_Receive>
				driveReverse(speed);
 1b6:	88 0f       	add	r24, r24
 1b8:	0e 94 33 01 	call	0x266	; 0x266 <driveReverse>
				break;
 1bc:	25 c0       	rjmp	.+74     	; 0x208 <receiveMessage+0x112>
			case 0x09:	// Rotate left with the specified speed
				speed = SPI_Receive() << 1;
 1be:	0e 94 76 00 	call	0xec	; 0xec <SPI_Receive>
				rotateLeft(speed);
 1c2:	88 0f       	add	r24, r24
 1c4:	0e 94 41 01 	call	0x282	; 0x282 <rotateLeft>
				break;
 1c8:	1f c0       	rjmp	.+62     	; 0x208 <receiveMessage+0x112>
			case 0x0A:	// Rotate right with the specified speed
				speed = SPI_Receive() << 1;
 1ca:	0e 94 76 00 	call	0xec	; 0xec <SPI_Receive>
				rotateRight(speed);
 1ce:	88 0f       	add	r24, r24
 1d0:	0e 94 4f 01 	call	0x29e	; 0x29e <rotateRight>
				break;
 1d4:	19 c0       	rjmp	.+50     	; 0x208 <receiveMessage+0x112>
			case 0x0B:	// Close the claw
				gripClaw();
 1d6:	0e 94 92 01 	call	0x324	; 0x324 <gripClaw>
				break;
 1da:	16 c0       	rjmp	.+44     	; 0x208 <receiveMessage+0x112>
			case 0x0C:	// Open the claw
				releaseClaw();
 1dc:	0e 94 82 01 	call	0x304	; 0x304 <releaseClaw>
				break;
 1e0:	13 c0       	rjmp	.+38     	; 0x208 <receiveMessage+0x112>
			case 0x0D: //STOP
				wheelSpeeds(0, 0);
 1e2:	60 e0       	ldi	r22, 0x00	; 0
 1e4:	80 e0       	ldi	r24, 0x00	; 0
 1e6:	0e 94 7f 01 	call	0x2fe	; 0x2fe <wheelSpeeds>
				break;
 1ea:	0e c0       	rjmp	.+28     	; 0x208 <receiveMessage+0x112>
 1ec:	69 01       	movw	r12, r18
			default:	// Fetch the message anyway								
				for(int i = 0; i < size; i++) {
 1ee:	e1 2c       	mov	r14, r1
 1f0:	f1 2c       	mov	r15, r1
					unknownMessage[i] = SPI_Receive();
 1f2:	0e 94 76 00 	call	0xec	; 0xec <SPI_Receive>
 1f6:	f6 01       	movw	r30, r12
 1f8:	81 93       	st	Z+, r24
 1fa:	6f 01       	movw	r12, r30
				break;
			case 0x0D: //STOP
				wheelSpeeds(0, 0);
				break;
			default:	// Fetch the message anyway								
				for(int i = 0; i < size; i++) {
 1fc:	ff ef       	ldi	r31, 0xFF	; 255
 1fe:	ef 1a       	sub	r14, r31
 200:	ff 0a       	sbc	r15, r31
 202:	ea 14       	cp	r14, r10
 204:	fb 04       	cpc	r15, r11
 206:	ac f3       	brlt	.-22     	; 0x1f2 <receiveMessage+0xfc>
				}
				break;
		}
	}

 208:	0f b6       	in	r0, 0x3f	; 63
 20a:	f8 94       	cli
 20c:	1e bf       	out	0x3e, r17	; 62
 20e:	0f be       	out	0x3f, r0	; 63
 210:	0d bf       	out	0x3d, r16	; 61
 212:	df 91       	pop	r29
 214:	cf 91       	pop	r28
 216:	1f 91       	pop	r17
 218:	0f 91       	pop	r16
 21a:	ff 90       	pop	r15
 21c:	ef 90       	pop	r14
 21e:	df 90       	pop	r13
 220:	cf 90       	pop	r12
 222:	bf 90       	pop	r11
 224:	af 90       	pop	r10
 226:	08 95       	ret

00000228 <main>:
#define REVERSE 0

char direction = FORWARD;

int main(void) {
	SPI_Init();								// Initiate SPI as a slaves
 228:	0e 94 70 00 	call	0xe0	; 0xe0 <SPI_Init>
	init_pwm();								// Initiates the pins used for PWM
 22c:	0e 94 4e 00 	call	0x9c	; 0x9c <init_pwm>
	while(1) {
		//gripClaw();
		//_delay_ms(2500);
		//releaseClaw();
		//_delay_ms(500);
		receiveMessage();
 230:	0e 94 7b 00 	call	0xf6	; 0xf6 <receiveMessage>
 234:	fd cf       	rjmp	.-6      	; 0x230 <main+0x8>

00000236 <setDirection>:
	}
}

// Set the character keeping track of the direction the robot is traveling in
void setDirection(uint8_t dir) {
	if(dir == 1) {
 236:	81 30       	cpi	r24, 0x01	; 1
 238:	19 f4       	brne	.+6      	; 0x240 <setDirection+0xa>
		direction = FORWARD;
 23a:	80 93 60 00 	sts	0x0060, r24
 23e:	08 95       	ret
	}
	else if(dir == 0) {
 240:	81 11       	cpse	r24, r1
 242:	02 c0       	rjmp	.+4      	; 0x248 <setDirection+0x12>
		direction = REVERSE;
 244:	10 92 60 00 	sts	0x0060, r1
 248:	08 95       	ret

0000024a <driveForward>:
	}
}

// The robot drives forward
void driveForward(uint8_t speed) {
	if(direction == REVERSE) {
 24a:	90 91 60 00 	lds	r25, 0x0060
 24e:	91 11       	cpse	r25, r1
 250:	05 c0       	rjmp	.+10     	; 0x25c <driveForward+0x12>
		PORTA &= ~(1<<WHEEL_DIRECTION_L);		// Set wheel direction to reverse by
 252:	d8 98       	cbi	0x1b, 0	; 27
		PORTA &= ~(1<<WHEEL_DIRECTION_R);		// clearing the direction pins
 254:	d9 98       	cbi	0x1b, 1	; 27
		setSpeed(speed);
 256:	0e 94 5c 00 	call	0xb8	; 0xb8 <setSpeed>
 25a:	08 95       	ret
	}
	else {
		PORTA |= (1<<WHEEL_DIRECTION_L);		// Set wheel direction to forward by
 25c:	d8 9a       	sbi	0x1b, 0	; 27
		PORTA |= (1<<WHEEL_DIRECTION_R);		// setting the direction pins
 25e:	d9 9a       	sbi	0x1b, 1	; 27
		setSpeed(speed);
 260:	0e 94 5c 00 	call	0xb8	; 0xb8 <setSpeed>
 264:	08 95       	ret

00000266 <driveReverse>:
	return;
}

// The robot drives in reverse
void driveReverse(uint8_t speed) {
	if(direction == REVERSE) {
 266:	90 91 60 00 	lds	r25, 0x0060
 26a:	91 11       	cpse	r25, r1
 26c:	05 c0       	rjmp	.+10     	; 0x278 <driveReverse+0x12>
		PORTA |= (1<<WHEEL_DIRECTION_L);		// Set wheel direction to forward by
 26e:	d8 9a       	sbi	0x1b, 0	; 27
		PORTA |= (1<<WHEEL_DIRECTION_R);		// setting the direction pins
 270:	d9 9a       	sbi	0x1b, 1	; 27
		setSpeed(speed);
 272:	0e 94 5c 00 	call	0xb8	; 0xb8 <setSpeed>
 276:	08 95       	ret
	}
	else {
		PORTA &= ~(1<<WHEEL_DIRECTION_L);		// Set wheel direction to reverse by
 278:	d8 98       	cbi	0x1b, 0	; 27
		PORTA &= ~(1<<WHEEL_DIRECTION_R);		// clearing the direction pins
 27a:	d9 98       	cbi	0x1b, 1	; 27
		setSpeed(speed);
 27c:	0e 94 5c 00 	call	0xb8	; 0xb8 <setSpeed>
 280:	08 95       	ret

00000282 <rotateLeft>:
	return;
}

// The robot rotates to the left
void rotateLeft(uint8_t speed) {
	if(direction == REVERSE){
 282:	90 91 60 00 	lds	r25, 0x0060
 286:	91 11       	cpse	r25, r1
 288:	05 c0       	rjmp	.+10     	; 0x294 <rotateLeft+0x12>
		PORTA |= (1<<WHEEL_DIRECTION_L);		// Make the robot turn right by setting
 28a:	d8 9a       	sbi	0x1b, 0	; 27
		PORTA &= ~(1<<WHEEL_DIRECTION_R);		// the left wheels to forward and vice versa
 28c:	d9 98       	cbi	0x1b, 1	; 27
		setSpeed(speed);
 28e:	0e 94 5c 00 	call	0xb8	; 0xb8 <setSpeed>
 292:	08 95       	ret
	}
	else {
		PORTA &= ~(1<<WHEEL_DIRECTION_L);		// Make the robot turn left by setting
 294:	d8 98       	cbi	0x1b, 0	; 27
		PORTA |= (1<<WHEEL_DIRECTION_R);		// the right wheels to forward and vice versa
 296:	d9 9a       	sbi	0x1b, 1	; 27
		setSpeed(speed);
 298:	0e 94 5c 00 	call	0xb8	; 0xb8 <setSpeed>
 29c:	08 95       	ret

0000029e <rotateRight>:
	return;
}

// The robot rotates to the right
void rotateRight(uint8_t speed) {
	if(direction == REVERSE){
 29e:	90 91 60 00 	lds	r25, 0x0060
 2a2:	91 11       	cpse	r25, r1
 2a4:	05 c0       	rjmp	.+10     	; 0x2b0 <rotateRight+0x12>
		PORTA &= ~(1<<WHEEL_DIRECTION_L);		// Make the robot turn left by setting
 2a6:	d8 98       	cbi	0x1b, 0	; 27
		PORTA |= (1<<WHEEL_DIRECTION_R);		// the right wheels to forward and vice versa
 2a8:	d9 9a       	sbi	0x1b, 1	; 27
		setSpeed(speed);
 2aa:	0e 94 5c 00 	call	0xb8	; 0xb8 <setSpeed>
 2ae:	08 95       	ret
	}
	else {
		PORTA |= (1<<WHEEL_DIRECTION_L);		// Make the robot turn right by setting
 2b0:	d8 9a       	sbi	0x1b, 0	; 27
		PORTA &= ~(1<<WHEEL_DIRECTION_R);		// the left wheels to forward and vice versa
 2b2:	d9 98       	cbi	0x1b, 1	; 27
		setSpeed(speed);
 2b4:	0e 94 5c 00 	call	0xb8	; 0xb8 <setSpeed>
 2b8:	08 95       	ret

000002ba <leftWheelDirection>:
	return;
}

// Set the direction of the left wheel pair according to input
void leftWheelDirection(uint8_t dir) {
	if(direction == REVERSE) {
 2ba:	90 91 60 00 	lds	r25, 0x0060
 2be:	91 11       	cpse	r25, r1
 2c0:	05 c0       	rjmp	.+10     	; 0x2cc <leftWheelDirection+0x12>
		if(dir == 1) {
 2c2:	91 e0       	ldi	r25, 0x01	; 1
 2c4:	81 30       	cpi	r24, 0x01	; 1
 2c6:	09 f4       	brne	.+2      	; 0x2ca <leftWheelDirection+0x10>
 2c8:	90 e0       	ldi	r25, 0x00	; 0
			dir = 0;
 2ca:	89 2f       	mov	r24, r25
		else {
			dir = 1;
		}
	}
	
	if(dir == 1) {
 2cc:	81 30       	cpi	r24, 0x01	; 1
 2ce:	11 f4       	brne	.+4      	; 0x2d4 <leftWheelDirection+0x1a>
		PORTA |= (1 << WHEEL_DIRECTION_L);		
 2d0:	d8 9a       	sbi	0x1b, 0	; 27
 2d2:	08 95       	ret
	}
	else if(dir == 0) {
 2d4:	81 11       	cpse	r24, r1
 2d6:	01 c0       	rjmp	.+2      	; 0x2da <leftWheelDirection+0x20>
		PORTA &= ~(1 << WHEEL_DIRECTION_L);
 2d8:	d8 98       	cbi	0x1b, 0	; 27
 2da:	08 95       	ret

000002dc <rightWheelDirection>:
	}
}

// Set the direction of the right wheel pair according to input
void rightWheelDirection(uint8_t dir) {
	if(direction == REVERSE) {
 2dc:	90 91 60 00 	lds	r25, 0x0060
 2e0:	91 11       	cpse	r25, r1
 2e2:	05 c0       	rjmp	.+10     	; 0x2ee <rightWheelDirection+0x12>
		if(dir == 1) {
 2e4:	91 e0       	ldi	r25, 0x01	; 1
 2e6:	81 30       	cpi	r24, 0x01	; 1
 2e8:	09 f4       	brne	.+2      	; 0x2ec <rightWheelDirection+0x10>
 2ea:	90 e0       	ldi	r25, 0x00	; 0
			dir = 0;
 2ec:	89 2f       	mov	r24, r25
		else {
			dir = 1;
		}
	}
	
	if(dir == 1) {
 2ee:	81 30       	cpi	r24, 0x01	; 1
 2f0:	11 f4       	brne	.+4      	; 0x2f6 <rightWheelDirection+0x1a>
		PORTA |= (1 << WHEEL_DIRECTION_R);
 2f2:	d9 9a       	sbi	0x1b, 1	; 27
 2f4:	08 95       	ret
	}
	else if(dir == 0) {
 2f6:	81 11       	cpse	r24, r1
 2f8:	01 c0       	rjmp	.+2      	; 0x2fc <rightWheelDirection+0x20>
		PORTA &= ~(1 << WHEEL_DIRECTION_R);
 2fa:	d9 98       	cbi	0x1b, 1	; 27
 2fc:	08 95       	ret

000002fe <wheelSpeeds>:
}

// Set the speed of both wheel pairs
// QUESTION: Why is this needed?
void wheelSpeeds(uint8_t left_speed, uint8_t right_speed) {
	setSpeeds(left_speed, right_speed);
 2fe:	0e 94 5f 00 	call	0xbe	; 0xbe <setSpeeds>
 302:	08 95       	ret

00000304 <releaseClaw>:
}

// Calls PWM functions to release the claw
void releaseClaw() {
	clawEnable();
 304:	0e 94 68 00 	call	0xd0	; 0xd0 <clawEnable>
	clawRelease();
 308:	0e 94 65 00 	call	0xca	; 0xca <clawRelease>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 30c:	2f ef       	ldi	r18, 0xFF	; 255
 30e:	82 e5       	ldi	r24, 0x52	; 82
 310:	97 e0       	ldi	r25, 0x07	; 7
 312:	21 50       	subi	r18, 0x01	; 1
 314:	80 40       	sbci	r24, 0x00	; 0
 316:	90 40       	sbci	r25, 0x00	; 0
 318:	e1 f7       	brne	.-8      	; 0x312 <releaseClaw+0xe>
 31a:	00 c0       	rjmp	.+0      	; 0x31c <releaseClaw+0x18>
 31c:	00 00       	nop
	_delay_ms(300);
	clawDisable();
 31e:	0e 94 6c 00 	call	0xd8	; 0xd8 <clawDisable>
 322:	08 95       	ret

00000324 <gripClaw>:
}

// Calls PWM functions to close the claw
void gripClaw() {
	clawEnable();
 324:	0e 94 68 00 	call	0xd0	; 0xd0 <clawEnable>
	clawGrip();
 328:	0e 94 62 00 	call	0xc4	; 0xc4 <clawGrip>
 32c:	08 95       	ret

0000032e <__tablejump2__>:
 32e:	ee 0f       	add	r30, r30
 330:	ff 1f       	adc	r31, r31

00000332 <__tablejump__>:
 332:	05 90       	lpm	r0, Z+
 334:	f4 91       	lpm	r31, Z
 336:	e0 2d       	mov	r30, r0
 338:	09 94       	ijmp

0000033a <_exit>:
 33a:	f8 94       	cli

0000033c <__stop_program>:
 33c:	ff cf       	rjmp	.-2      	; 0x33c <__stop_program>
